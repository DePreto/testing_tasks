# задание № 1

"""
Дается таблица "create table dt (date_tt date, id_tt int, summa money)".
Запрос "select * from dt" приносит результат:
Date_tt id_tt summa
2017-02-05 333 446464.99
2017-02-05 339 201527.00
2017-02-05 345 328238.00
2017-02-06 333 431285.02
2017-02-06 339 203483.00
2017-02-06 345 284183.00
2017-02-07 333 376670.02
2017-02-07 339 180746.00
2017-02-07 345 259394.07
Надо пронумеровать записи внутри каждого значения поля "id_tt", т.е. добиться
следующего результата:
Date_tt id_tt summa rn
2017-02-05 333 446464.99 1
2017-02-06 333 431285.02 2
2017-02-07 333 376670.02 3
2017-02-06 339 203483.00 1
2017-02-05 339 201527.00 2
2017-02-07 339 180746.00 3
2017-02-05 345 328238.00 1
2017-02-06 345 284183.00 2
2017-02-07 345 259394.07 3
Задание: написать SQL-скрипт, который выполнит поставленную задачу
"""

numerate_rows_sql = """
SELECT date_tt, id_tt, summa, ROW_NUMBER() OVER(PARTITION BY id_tt ORDER BY id_tt)
FROM dt;
"""

# задание № 2

"""
Дается таблица DTT.
В таблице собраны агрегированные данные по продажам за весь период работы компании в разрезе дата, магазин, товар
(
date_tt date - дата, 
id_tt int - id магазина, 
id_tov int - id товара, 
qty int - количество проданного )
Вывести идентификаторы товаров-новинок ( id_tov) , которые стали продаваться впервые за последние 30 дней.
Задание: написать SQL-скрипт, который выполнит поставленную задачу
"""

newest_products_sql = """
SELECT DISTINCT(it_tov) FROM ddt WHERE DATE_PART('day', current_date - ddt.date_tt) <= 30;
"""

# DISTINCT > товар с одним id может встретиться в нескольких магазинах (id_tt), поскольку нас интересует конкретный id и мы гарантируем,
# что id товара не меняется в зависимости от магазина, отбрасываем дубликаты

# не совсем понятно о чём говорит колонка date_tt - о дате выхода товара на продажу / о последней дате продажи /
# или в таблице представлены построчно продажи товара за каждую дату
# (т.е. один и тот же товар в одном магазине встречается в таблице неоднократно с увеличивающимся счётчиком и конкретной даты продажи)
# в таком случае необходимо добавить соответствующее дополнительное условие (например, qty=0, что говорит о том, что имеющаяся дата - дата старта продаж)

# задание № 3

"""
Есть список, содержащий какое-то количество элементов - списков. Списки внутри состоят из двух элементов – целых чисел, 
которые обозначают id товаров (например, [[1102, 214], [214, 2007], [42, 315], [406, 2007], …]). 
Каждая пара внутри – пара аналогов товаров. Будем считать, что если товар 1 и товар 2 - аналоги, товар 2 и товар 3 – 
аналоги, то и товар 1 является аналогом товара 3, даже если этой пары нет в исходном списке 
(товар 1, товар 2 и товар 3 назовем группой аналогов).

Задение: написать функцию на Python, которая на вход принимает такой список списков и выводит на экран наиболее полные 
группы аналогов в виде кортежей 
"""


from typing import List


def from_chaos_to_order(chaos: List[List[int]]) -> None:
    result = []
    for pair in chaos:
        flag = False
        if not result:
            result.append(pair)
        else:
            for product_index, product in enumerate(pair):
                for group_index, group in enumerate(result):
                    if product in group:
                        second_product = pair[(product_index+1) % 2]  # (i + 1) % 2 - определяем индекс второго элемента (если match с индексом 0 > добавляем 1, если с 1 > 0)
                        if second_product not in group:  # исключаем дубликаты
                            result[group_index].append(second_product)
                        flag = True
                        break
                if flag:
                    break
            else:
                result.append(pair)
    for group in result:
        print(tuple(group))


test_data = [[1102, 214], [214, 2007], [42, 315], [406, 2007], [4011, 512], [315, 90], [80, 42], [1, 2], [406, 2007]]

from_chaos_to_order(test_data)
